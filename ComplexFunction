package Ex1;

import java.util.ArrayList;

import org.hamcrest.core.SubstringMatcher;

public class ComplexFunction implements complex_function {

	private Operation op;
	private function left, right;

	public ComplexFunction(Operation op, function left, function right) {
		this.op = op;
		this.left = left;
		this.right = right;
	}

	public ComplexFunction() {
		this.op = null;
		this.left = null;
		this.right = null;
	}
	public ComplexFunction(function left) {
		this.op = Operation.None;
		this.left = left;
		this.right = null;
	}

	public boolean isCorrect(String s) {
		int numOf = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '(') {
				numOf++;
			}
			if (s.charAt(i) == ')') {
				numOf--;
			}
			if (numOf < 0) {
				return false;
			}
		}
		if (numOf != 0) {
			return false;
		}
		return true;

	}

	public function initFromString(String s) {

		if (!isCorrect(s)) {
			throw new RuntimeException("Uncorrect");
		}
		if (s.startsWith("plus")) {
			this.op = Operation.Plus;
			s = s.substring(5, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		if (s.startsWith("Divid")) {
			this.op = Operation.Divid;
			s = s.substring(6, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		if (s.startsWith("mul")) {
			this.op = Operation.Times;
			s = s.substring(4, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		if (s.startsWith("max")) {
			this.op = Operation.Max;
			s = s.substring(4, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		if (s.startsWith("min")) {
			this.op = Operation.Min;
			s = s.substring(4, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		if (s.startsWith("com")) {
			this.op = Operation.Comp;
			s = s.substring(4, s.length());
			this.left = cutString(s);
			s = s.substring(s.indexOf(",") + 1);
			this.right = cutString(s);
		}
		ComplexFunction cf = new ComplexFunction(op, left, right);
		return cf;
	}

	public function cutString(String s) {
		String n = "";
		for (int i = 0; i < s.length(); i++) {
			if (i >= 1 && (s.charAt(i) == ',' || s.charAt(i) == ')')) {
				break;
			}
			n += s.charAt(i);
		}
		if (n.contains("+") || n.contains("-")) {
			Polynom p = new Polynom(n);
			return p;
		} else {
			Monom a = new Monom(n);
			return a;
		}

	}

	public double f(double x) {
		return x;
	}

	/**
	 * return a String representing this complex function
	 */
	/*
	 * public String toString() { String ans = ""; ans += cf.get(0); for (int i = 1;
	 * i < this.cf.size(); i++) { if(cf.get(i).toString().charAt(0) ) ans +=
	 * cf.get(i); } return ans; }
	 */
	public function copy() {
		String copyS = this.toString();
		ComplexFunction copy = new ComplexFunction();
		copy.initFromString(copyS);
		return copy;
	}

	public boolean equals(Object obj) {
		return false;
	}

	/**
	 * Add to this complex_function the f1 complex_function
	 * 
	 * @param f1 the complex_function which will be added to this complex_function.
	 */
	public void plus(function f1) {
		function copy;
		copy = this.copy();
		this.left = copy;
		this.right = f1;
		this.op = Operation.Plus;
	}

	/**
	 * Multiply this complex_function with the f1 complex_function
	 * 
	 * @param f1 the complex_function which will be multiply be this
	 *           complex_function.
	 */
	public void mul(function f1) {
		function copy;
		copy = this.copy();
		this.left = copy;
		this.right = f1;
		this.op = Operation.Times;
	}

	/**
	 * Divides this complex_function with the f1 complex_function
	 * 
	 * @param f1 the complex_function which will be divid this complex_function.
	 */
	public void div(function f1) {
		function copy;
		copy = this.copy();
		this.left = copy;
		this.right = f1;
		this.op = Operation.Divid;
	}

	/**
	 * Computes the maximum over this complex_function and the f1 complex_function
	 * 
	 * @param f1 the complex_function which will be compared with this
	 *           complex_function - to compute the maximum.
	 */
	public void max(function f1) {
		function copy;
		copy = this.copy();
		this.left = copy;
		this.right = f1;
		this.op = Operation.Max;
	}

	/**
	 * Computes the minimum over this complex_function and the f1 complex_function
	 * 
	 * @param f1 the complex_function which will be compared with this
	 *           complex_function - to compute the minimum.
	 */
	public void min(function f1) {
		function copy;
		copy = this.copy();
		this.left = copy;
		this.right = f1;
		this.op = Operation.Min;
	}

	/**
	 * This method wrap the f1 complex_function with this function: this.f(f1(x))
	 * 
	 * @param f1 complex function
	 */
	public void comp(function f1) {

	}

	/**
	 * returns the left side of the complex function - this side should always
	 * exists (should NOT be null).
	 * 
	 * @return a function representing the left side of this complex funcation
	 */
	public function left() {
		return this.left;
	}

	/**
	 * returns the right side of the complex function - this side might not exists
	 * (aka equals null).
	 * 
	 * @return a function representing the left side of this complex funcation
	 */
	public function right() {
		if (this.right != null) {
			return this.right;
		}
		return null;
	}

	/**
	 * The complex_function oparation: plus, mul, div, max, min, comp
	 * 
	 * @return
	 */
	public Operation getOp() {
		return this.op;
	}

	public String toString() {
		String ans = "";
		ans += this.op + "(" + this.left + "," + this.right + ")";
		return ans;
	}
}
